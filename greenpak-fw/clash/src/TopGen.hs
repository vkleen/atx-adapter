{-# OPTIONS_GHC -Wall -Wno-orphans #-}

{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE DeriveLift         #-}
{-# LANGUAGE LambdaCase         #-}
{-# LANGUAGE PatternSynonyms    #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TypeOperators      #-}
{-# LANGUAGE TemplateHaskell    #-}
{-# LANGUAGE ViewPatterns       #-}

-- | Tools to automatically generated @'TopEntity'@ annotations for compiled
-- Clash circuits.
module TopGen
  ( makeSynthesize
  , makeSynthesizeWithName
  ) where

-- base
import           Prelude

-- template-haskell
import           Language.Haskell.TH
import           Language.Haskell.TH.Syntax

-- clash
import           Clash.NamedTypes            ((:::))
import           Clash.Annotations.TopEntity (PortName(..), TopEntity(..))

import Debug.Trace

--
-- utilities
--

-- matches against `"nam" ::: ty` using (:::) from Clash, but we
-- can't check the type constructor here :(
pattern NamedTy :: Type -> String -> Type
pattern NamedTy con nam <-
  AppT (AppT con (LitT (StrTyLit nam))) _

-- matches a type `a -> b`
pattern ArrowTy :: Type -> Type -> Type
pattern ArrowTy a b = AppT (AppT ArrowT a) b

unAppsT :: Type -> [Type]
unAppsT = go []
  where go xs (AppT f x) = go (x : xs) f
        go xs ty = ty : xs

isTupT :: Type -> Bool
isTupT (unAppsT -> (TupleT _ : _)) = True
isTupT _ = False

collectTupT :: Type -> [Type]
collectTupT ty | isTupT ty = go (unAppsT ty)
               | otherwise = [ty]
  where go xs@(TupleT _ : _) = concatMap collectTupT (tail xs)
        go xs = xs

-- | Given an multi-arity function type @f :: a -> b -> c -> ...@, get
-- the final return type.
getReturnTy :: Type -> Q Type
getReturnTy (ArrowTy _ b) = getReturnTy b
getReturnTy b             = return b

makeSynthesizeWithName' :: Name -> Maybe String -> DecsQ
makeSynthesizeWithName' n topName = reify n >>= \case
  VarI nam typ _ -> do
    -- helpers
    let prag t = PragmaD (AnnP (valueAnnotation nam) t)

    -- get a Name for this type operator so we can check it
    -- in the ArrowTy case
    nty <- [t| (:::) |]

    -- examine the arguments
    let examine ty = go ty [] where
          go (ArrowTy (NamedTy con a) b) xs
            | con == nty
            = do { v <- go b xs; return (a:v) }

          go (ArrowTy _ _) _
            = fail $ "makeSynthesize: All types for an autogenerated "
            ++ "top-entity (both input and output) must have a name!"

          go _ xs = return xs

    ins <- map PortName <$> examine typ
    out <- getReturnTy typ >>= \case
      -- single output
      NamedTy con r | con == nty -> return $ PortName r

      -- multi output
      xs@(isTupT -> True) -> do
        let go (NamedTy con r) | con == nty = return (PortName r)
            go _ = fail $ "makeSynthesize: Output tuple must have "
                 ++ "names for all components!"

        PortProduct mempty <$> mapM go (collectTupT xs)

      -- invalid type
      _ -> fail "makeSynthesize: Invalid return type!"

    -- Return the annotation
    let realName = case topName of
          Just nn -> nn             -- user specified name
          Nothing -> nameBase nam   -- auto-generated name
    top <- lift $ Synthesize
                    { t_name   = realName
                    , t_inputs = ins
                    , t_output = out
                    }
    return [prag top]

  -- failure case: we weren't provided with the name of a binder
  _ -> fail "makeSynthesize: invalid Name, must be a top-level binding!"

-- | Automatically create a @'TopEntity'@ for a given @'Name'@, using the given
-- @'String'@ to specify the name of the generated RTL entity.
--
-- The function arguments and return values of the function specified by the
-- given @'Name'@ must be annotated with @'(:::)'@. This annotation provides the
-- given name of the port.
makeSynthesizeWithName :: Name -> String -> DecsQ
makeSynthesizeWithName nam top = makeSynthesizeWithName' nam (Just top)

-- | Automatically create a @'TopEntity'@ for a given @'Name'@. The name of the
-- generated RTL entity will be the name of the function that has been
-- specified; e.g. @'makeSynthesize' 'foobar@ will generate a @foobar@ module.
--
-- The function arguments and return values of the function specified by the
-- given @'Name'@ must be annotated with @'(:::)'@. This annotation provides the
-- given name of the port.
makeSynthesize :: Name -> DecsQ
makeSynthesize nam = makeSynthesizeWithName' nam Nothing
