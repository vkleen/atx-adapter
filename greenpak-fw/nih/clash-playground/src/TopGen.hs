{-# OPTIONS_GHC -Wall -Wno-orphans #-}

{-# LANGUAGE DataKinds          #-}
{-# LANGUAGE DeriveLift         #-}
{-# LANGUAGE LambdaCase         #-}
{-# LANGUAGE PatternSynonyms    #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TypeOperators      #-}
{-# LANGUAGE TemplateHaskell    #-}
{-# LANGUAGE ViewPatterns       #-}

-- | Tools to automatically generated @'TopEntity'@ annotations for compiled
-- Clash circuits.
module TopGen
  ( makeTopEntity
  , makeTopEntityWithName
  ) where

-- base
import           Prelude

-- template-haskell
import           Language.Haskell.TH
import           Language.Haskell.TH.Syntax

-- clash
import           Clash.NamedTypes            ((:::))
import           Clash.Annotations.TopEntity (PortName(..), TopEntity(..))

--
-- utilities
--

-- matches against `"nam" ::: ty` using (:::) from Clash, but we
-- can't check the type constructor here :(
pattern NamedTy :: Type -> String -> Type
pattern NamedTy con nam <-
  SigT (AppT (AppT con (LitT (StrTyLit nam))) _) _

-- matches a type `a -> b`
pattern ArrowTy :: Type -> Type -> Type
pattern ArrowTy a b = AppT (AppT ArrowT a) b

-- orphans. TODO FIXME: move these upstream
deriving instance Lift PortName
deriving instance Lift TopEntity

isTupT :: Type -> Bool
isTupT (AppT x _) = isTupT x
isTupT (TupleT _) = True
isTupT _          = False

collectTupT :: Type -> [Type]
collectTupT (AppT (TupleT _) v) = [v]
collectTupT (AppT f v)          = collectTupT f ++ collectTupT v
collectTupT (TupleT _)          = []
collectTupT x                   = [x]

-- | Given an multi-arity function type @f :: a -> b -> c -> ...@, get
-- the final return type.
getReturnTy :: Type -> Q Type
getReturnTy (ArrowTy _ b) = getReturnTy b
getReturnTy b             = return b

makeTopEntityWithName' :: Name -> Maybe String -> DecsQ
makeTopEntityWithName' n topName = reify n >>= \case
  VarI nam typ _ -> do
    -- helpers
    let prag t = PragmaD (AnnP (valueAnnotation nam) t)

    -- get a Name for this type operator so we can check it
    -- in the ArrowTy case
    nty <- [t| (:::) |]

    -- examine the arguments
    let examine ty = go ty [] where
          go (ArrowTy (NamedTy con a) b) xs
            | con == nty
            = do { v <- go b xs; return (a:v) }

          go (ArrowTy _ _) _
            = fail $ "makeTopEntity: All types for an autogenerated "
            ++ "top-entity (both input and output) must have a name!"

          go _ xs = return xs

    ins <- map PortName <$> examine typ
    out <- getReturnTy typ >>= \case
      -- single output
      NamedTy con r | con == nty -> return $ PortName r

      -- multi output
      xs@(isTupT -> True) -> do
        let go (NamedTy con r) | con == nty = return (PortName r)
            go _ = fail $ "makeTopEntity: Output tuple must have "
                 ++ "names for all components!"

        PortField mempty <$> mapM go (collectTupT xs)

      -- invalid type
      _ -> fail "makeTopEntity: Invalid return type!"

    -- Return the annotation
    let realName = case topName of
          Just nn -> nn             -- user specified name
          Nothing -> nameBase nam   -- auto-generated name
    top <- lift $ TopEntity
                    { t_name   = realName
                    , t_inputs = ins
                    , t_output = out
                    }
    return [prag top]

  -- failure case: we weren't provided with the name of a binder
  _ -> fail "makeTopEntity: invalid Name, must be a top-level binding!"

-- | Automatically create a @'TopEntity'@ for a given @'Name'@, using the given
-- @'String'@ to specify the name of the generated RTL entity.
--
-- The function arguments and return values of the function specified by the
-- given @'Name'@ must be annotated with @'(:::)'@. This annotation provides the
-- given name of the port.
makeTopEntityWithName :: Name -> String -> DecsQ
makeTopEntityWithName nam top = makeTopEntityWithName' nam (Just top)

-- | Automatically create a @'TopEntity'@ for a given @'Name'@. The name of the
-- generated RTL entity will be the name of the function that has been
-- specified; e.g. @'makeTopEntity' 'foobar@ will generate a @foobar@ module.
--
-- The function arguments and return values of the function specified by the
-- given @'Name'@ must be annotated with @'(:::)'@. This annotation provides the
-- given name of the port.
makeTopEntity :: Name -> DecsQ
makeTopEntity nam = makeTopEntityWithName' nam Nothing
